install.packages("lmSupport")
install.packages("car")
install.packages("rgl")
install.packages("plot3D")
install.packages("rgl")
library(lmSupport)
library(car)
# Pacotes para graficos
library(rgl)
library(plot3D)
#___________________________________________________________________________________
#### Importar seu conjunto de tabela1 para o R
## Opção 1: via Google Drive
LinkAcessoDrive<-"https://docs.google.com/spreadsheets/d/e/2PACX-1vS0SeKu3W4ybwa3QegsMSXHTbiJqo0tmemyuUIR4SSRBF6DVyNHJvsXK-dVWkmJmybuM8jNYyFS5pvh/pub?gid=0&single=true&output=csv"; tabela1<-read.csv(url(LinkAcessoDrive), sep = ",",dec = "."); rm(LinkAcessoDrive)
View(tabela1)
View(tabela1)
View(tabela1)
View(tabela1)
modelo1 <- lm(SAT ~ Expend, data=tabela1)
summary(modelo1)
#___________________________________________________________________________________
#### Importar seu conjunto de tabela1 para o R
## Opção 1: via Google Drive
LinkAcessoDrive<-"https://docs.google.com/spreadsheets/d/e/2PACX-1vS0SeKu3W4ybwa3QegsMSXHTbiJqo0tmemyuUIR4SSRBF6DVyNHJvsXK-dVWkmJmybuM8jNYyFS5pvh/pub?gid=0&single=true&output=csv"; tabela1<-read.csv(url(LinkAcessoDrive), sep = ",",dec = "."); rm(LinkAcessoDrive)
# Pacotes para analise de tabela1
library(lmSupport)
library(car)
# Pacotes para graficos
library(rgl)
library(plot3D)
tabela1
#######################################
# Modelo 1 - Regressão linear simples #
#######################################
modelo1 <- lm(SAT ~ Expend, data=tabela1)
summary(modelo1)
#######################################
# Modelo 2 - Regressão linear multipla#
#######################################
modelo2 <- lm(SAT ~ Expend + LogPctSAT, data=tabela1)
summary(modelo2)
#######################################
# Modelo 3 - Regressão linear multipla#
#######################################
modelo3 <- lm(SAT ~ Expend + LogPctSAT + Salary, data=tabela1)
summary(modelo3)
#######################################
# Modelo 4 - modelo nulo
#######################################
modelo4 <- lm(SAT ~ 1, data=tabela1)
summary(modelo1)
summary(modelo4)
#___________________________________________________________________________________
# Seleção de modelos I - AIC e BIC
# AIC
AIC(modelo1,modelo2,modelo3,modelo4)
# BIC
BIC(modelo1,modelo2,modelo3,modelo4)
#___________________________________________________________________________________
# Seleção de modelos II - Stepwise e Forward model selection
# Stepwise model selection
step(modelo3)
# Forward model selection
ModeloVazio<- lm(SAT~1,data=tabela1)
ModeloCompleto<- formula(SAT ~ Expend + LogPctSAT + Salary)
step(ModeloVazio, direction = "forward", scope=ModeloCompleto)
# Forward model selection
ModeloVazio<- lm(SAT~1,data=tabela1)
ModeloCompleto<- formula(SAT ~ Expend + LogPctSAT + Salary)
step(ModeloVazio, direction = "forward", scope=ModeloCompleto)
# Variance Inflation Factor
vif(modelo2)
Verificar  residuos
residuos <- resid(modelo2)
valoresprevistos <- predict(modelo2, type = "response")
op <- par(mfrow = c(2, 2), mar = c(5, 4, 2, 2))
# Fazer um gráfico de resíduos vs valores previstos para avaliar se: I) A relação é linear; II)Existe homocedasticidade (pontos estão igualmente distribuídos igualmente em toda a área do gráfico)
plot(residuos~valoresprevistos,xlab = "Valores previstos",ylab = "Residuos", main = "Residuos vs valores previstos", cex.main=.75) # Aqui vamos ver a homocedasticidade. Se  estiver tudo certo, você deve observar pontos uniformemente distirbuidos ao redor da linha que corta o eixo x em 0.
abline(0,0, col="red", lty=2, lwd =2)
# Avaliar por histograma/boxplot se os resíduos tem distribuição normal
hist(residuos, xlab = "Residuos", main = "Histograma dos resíduos", cex.main=.75)
# Resíduos vs. variável explanatória (para testar independência)
plot(residuos~tabela1$Expend, main = "Resíduos vs. variável explanatória 1 (Expend)", xlab = "Valores observados de Expend",ylab = "Residuos", cex.main=.75)
abline(0,0, col="red", lty=2, lwd =2)
plot(residuos~tabela1$LogPctSAT, main = "Resíduos vs. variável explanatória 2 (LogPctSAT)", xlab = "Valores observados de LogPctSAT",ylab = "Residuos", cex.main=.75)
abline(0,0, col="red", lty=2, lwd =2)
# Voltar a area de plotar imagem para apenas 1 imagem por vez
par(mfrow = c(1, 1))
#___________________________________________________________________________________
# Confirmado que está tudo certo com o modelo, agora podemos avaliar as correlações parciais
# Partial & semipartial correlation
modelEffectSizes(modelo2)
### Criar gráfico com valores observados
CoresGraf<- rep("red", length(tabela1$Domineo))
CoresGraf[tabela1$Domineo=="SAT"] <- "blue"
# Plot 3D - Animado
plot3d(x=tabela1$Expend, y= tabela1$LogPctSAT,z = tabela1$SAT, xlab="Expend",  ylab="LogPctSAT", zlab="SAT", type="s" , col=CoresGraf)
# Pacotes para graficos
library(rgl)
library(plot3D)
CoresGraf<- rep("red", length(tabela1$Domineo))
CoresGraf[tabela1$Domineo=="SAT"] <- "blue"
# Plot 3D - Animado
plot3d(x=tabela1$Expend, y= tabela1$LogPctSAT,z = tabela1$SAT, xlab="Expend",  ylab="LogPctSAT", zlab="SAT", type="s" , col=CoresGraf)
# Plot 3D - Fixo
scatter3D(x=tabela1$Expend, y= tabela1$LogPctSAT, z = tabela1$SAT, main = "SAT ~ Expend + LogPctSAT", xlab="Expend", ylab="LogPctSAT", zlab="SAT", pch=21 , cex=2, col="white",bg=CoresGraf)
# Plot 3D - Fixo
scatter3D(x=tabela1$Expend, y= tabela1$LogPctSAT, z = tabela1$SAT, main = "SAT ~ Expend + LogPctSAT", xlab="Expend", ylab="LogPctSAT", zlab="SAT", pch=21 , cex=2, col="white",bg=CoresGraf)
plotdev(theta = 50, phi=25)
plotdev(theta = 90, phi=30)
# Plot 3D - Animado
plot3d(x=tabela1$Expend, y= tabela1$LogPctSAT,z = tabela1$SAT, xlab="Expend",  ylab="LogPctSAT", zlab="SAT", type="s" , col=CoresGraf)
plotdev(theta = 10, phi=50)
plotdev(theta = 0, phi=0)
plotdev(theta = 0, phi=50)
### Criar gráfico com valores previstos
# Criar conjunto de tabela1 para plotar no grafico 3D
GastoSimulado <- seq(from = 1, to = 15, by = .25) # Possiveis valores de gasto com aluno
PropSimulada <- seq(from = 1,to = 5, length.out = length(GastoSimulado))# Possiveis valores de proporção de alunos que vão fazer a prova
tamanho<-length(GastoSimulado)
CombinacoesPrevistas<-matrix(NA, ncol=3, nrow=tamanho*tamanho)
colnames(CombinacoesPrevistas)<-c("SAT", "Expend", "LogPctSAT")
CombinacoesPrevistas[,2]<-rep(GastoSimulado,times=tamanho)
CombinacoesPrevistas[,3]<-rep(PropSimulada,each=tamanho)
pb <- txtProgressBar(min = 0, max = length(CombinacoesPrevistas[,1]), style = 3)
for(i in 1:length(CombinacoesPrevistas[,1])){
CombinacoesPrevistas[i,1] <- predict(modelo2, newdata = data.frame(Expend=CombinacoesPrevistas[i,2], LogPctSAT=CombinacoesPrevistas[i,3]), type = "response")
setTxtProgressBar(pb, i)
}
z.SAT<-matrix(CombinacoesPrevistas[,1],ncol=tamanho,nrow=tamanho)# Possiveis resultados de prova, dado os valores simauldos de gasto e proporção que foi fazer a prova
# Plot 3D - Animado - Preto e Branco
plot3d(x=CombinacoesPrevistas[,2], y= CombinacoesPrevistas[,3], z = CombinacoesPrevistas[,1],  xlab="Expend",  ylab="LogPctSAT", zlab="SAT", size=20)
#### Grafico com cores
# Selecionar a cor de cada ponto
intensidade<-CombinacoesPrevistas[,1]/max(CombinacoesPrevistas[,1])
NomesCores<-jet.col(length(intensidade))
CoresGraf<-NomesCores[rank(intensidade)]
# Plot 3D - Animado - Cores
plot3d(x=CombinacoesPrevistas[,2], y= CombinacoesPrevistas[,3],  z = CombinacoesPrevistas[,1], xlab="Expend", ylab="LogPctSAT", zlab="SAT", type="p", col=CoresGraf, size=20)
# Plot 3D - Fixo - Cores
scatter3D(x=CombinacoesPrevistas[,2], y= CombinacoesPrevistas[,3], z = CombinacoesPrevistas[,1], main = "SAT ~ Expend + LogPctSAT", xlab="Expend",  ylab="LogPctSAT", zlab="SAT", pch=16 , cex=1.5, col=CoresGraf)
plotdev(theta = 40, phi=20)
grid.lines = 30
x.pred <- seq(min(tabela1$Expend), max(tabela1$Expend), length.out = grid.lines)
y.pred <- seq(min(tabela1$LogPctSAT), max(tabela1$LogPctSAT), length.out = grid.lines)
xy <- expand.grid( Expend = x.pred, LogPctSAT = y.pred)
z.pred <- matrix(predict(modelo2, newdata = xy),
nrow = grid.lines, ncol = grid.lines)
fitpoints <- predict(modelo2)
scatter3D(x=tabela1$Expend, y= tabela1$LogPctSAT,z = tabela1$SAT, pch = 18, cex = 2,
theta = 30, phi = 15, zlim=c(min(z.pred),max(z.pred)),
xlab="Expend", ylab="LogPctSAT", zlab="SAT" ,
surf = list(x = x.pred, y = y.pred, z = z.pred,   facets = NA, fit = fitpoints), main = "Valores observados e previstos")
